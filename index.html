<html>
<head>
    <title>DSTU</title>
</head>
<body>
    <script type="text/javascript" src="/js/uadstu.js"></script>
    <script type="text/javascript" src="/js/hex.js"></script>
    <script type="text/javascript" src="/js/int10.js"></script>
    <script type="text/javascript" src="/js/asn1.js"></script>
    <script type="text/javascript" src="/js/keycoder.js"></script>

    <h1>Key converter</h1>

    <p>
        This tool decodes private keys for Ukrainian cipher 4145-2002 from legacy formats.
        Drop files into this page. <b>We will NOT transmit keys over network for processing and advice you to disable internet connection while using this tool</b>.
    </p>

    <div id="drop_zone">Drop files here</div>
    <input id='pw_in' type="password" />
    <pre id="pem_out" ></pre>

    <p>
    Source code: <a href="https://github.com/muromec/dstukeys">github.com/muromec/dstukeys</a>
    </p>
    <p>Copyright Ilya Petrov <i>ilya.muromec@gmail.com</i>, 2014. You can send tips to 15qmFc9MR8z8YFBqkHcSoQGGxQgVrWdn7S.</p>

    <style>
    #drop_zone {
        border: 2px dashed #bbb;
        -moz-border-radius: 5px;
        -webkit-border-radius: 5px;
        border-radius: 5px;
        padding: 25px;
        text-align: center;
        font: 20pt bold 'Vollkorn';
        color: #bbb;
    }
    </style>
    <script>
        var read_buf = function(ptr, sz) {
            var ret = [], x=0;
            for(var i = 0; i < sz; i++) {
                x = getValue(ptr + i, 'i8');
                if(x < 0) {
                    x = 256 + x;
                }
                ret.push(x);
            }
            return ret;
        }
        var numberHex = function(numbrs, line) {
            var hex = [], h;
            for(var i = 0; i < numbrs.length; i++) {
                h = numbrs[i].toString(16);
                if(h.length == 1) {
                    h = "0" + h;
                }
                hex.push(h); 
                if( (i > 1) && (line !== undefined) && ((i%line) == line-1)) {
                    hex.push('\n');
                }
            }
            return hex.join("");
        }
        var B64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var numberB64 = function(numbrs, line) {
            var ret = [], b1, b2, b3, e1, e2, e3, e4, i=0;
            while(i < numbrs.length) {

                b1 = numbrs[i++];
                b2 = numbrs[i++];
                b3 = numbrs[i++];

                e1 = b1 >> 2;
                e2 = ((b1 & 3) << 4) | (b2 >> 4);
                e3 = ((b2 & 15) << 2) | (b3 >> 6);
                e4 = b3 & 63;

                ret.push(B64.charAt(e1));
                ret.push(B64.charAt(e2));
                ret.push(B64.charAt(e3));
                ret.push(B64.charAt(e4));

                if( (i > 0) && (line !== undefined) && ((i%line) == 0)) {
                    ret.push('\n');
                }
            }
            return ret.join("");
        }
        var convert_password = function(parsed, pw, raw) {
            var vm_out, vm_pw, vm_salt, args, argtypes, ret = null;
            vm_out = allocate(32, 'i8', ALLOC_STACK);
            vm_pw = allocate(intArrayFromString(pw), 'i8', ALLOC_STACK);
            if(parsed.format == 'IIT') {
                args = [vm_pw, pw.length, vm_out];
                argtypes = ['number', 'number', 'number'];

                ret = Module.ccall('iit_convert_password', 'number', argtypes, args);
            }
            if(parsed.format == 'PBES2') {
                args = [vm_pw, pw.length, asnbuf(parsed.salt), parsed.salt.length, parsed.iters, vm_out];
                argtypes = ['number', 'number', 'number', 'number', 'number'];
                ret = Module.ccall('pbes2_convert_password', 'number', argtypes, args);
            }
            if(ret == 0) {
                if(raw === true) {
                    return vm_out;
                } else {
                    return read_buf(vm_out, 32);
                }
            } else {
                throw new Error("Failed to convert key");
            }
        }
        var decode_data = function(parsed, pw) {
            var args, argtypes, bdata, bkey, bmac, rbuf, ret;

            bkey = convert_password(parsed, pw, true);
            if(parsed.format === 'IIT') {
                rbuf = allocate(parsed.body.length + parsed.pad.length, 'i8', ALLOC_STACK);
                args = [asnbuf([parsed.body, parsed.pad]), parsed.body.length, bkey, asnbuf(parsed.mac), rbuf];
                argtypes = ['number', 'number', 'number', 'number'];
                ret = Module.ccall('iit_decode_data', 'number', argtypes, args)
            }
            if(parsed.format == 'PBES2') {
                rbuf = allocate(parsed.body.length, 'i8', ALLOC_STACK);
                args = [asnbuf(parsed.body), parsed.body.length, bkey, asnbuf(parsed.iv), asnbuf(parsed.sbox), rbuf];
                argtypes = ['number', 'number', 'number', 'number', 'number', 'number'];
                ret = Module.ccall('pbes2_decode_data', 'number', argtypes, args);

            }
            if(ret == 0) {
                return read_buf(rbuf, parsed.body.length, 'hex');
            }
        }
        var asnbuf = function(asn_l) {
            var buf_len = 0, buf, start, end, off = 0,
                start, end;

            if(asn_l.stream !== undefined) {
                asn_l = [asn_l];
            }

            for(var i = 0; i < asn_l.length; i++) {
                buf_len += asn_l[i].length;
            }

            buf = allocate(buf_len, 'i8', ALLOC_STACK);

            for(var j = 0; j < asn_l.length; j++) {
                var asn = asn_l[j], i;
                start = asn.posContent();
                for(i = 0; i < asn.length; i++) {
                    setValue(buf + i + off, asn.stream.get(start + i), 'i8');
                }
                off += i;
            }
            return buf;
        }


        var decode_import = function(indata, password) {
            var parser = new Keycoder(),
                parsed = parser.parse(indata),
                decoded = decode_data(parsed, password);

            if(decoded == undefined) {
                return;
            }
            if(parser.is_valid(decoded) != true) {
                return;
            }
            return numberB64(decoded, 42);
        }
    </script>

    <script>
    function handleFileSelect(evt) {
        evt.stopPropagation();
        evt.preventDefault();

        var files = evt.dataTransfer.files; // FileList object.
        var password = document.getElementById('pw_in').value;
        if((password === undefined) || password.length == 0) {
            return;
        }

        // files is a FileList of File objects. List some properties.
        var output = [];
        for (var i = 0, f; f = files[i]; i++) {
            var reader = new FileReader();
            reader.onload = function(evt) {
                var u8 = new Uint8Array(evt.target.result),
                    data = decode_import(u8, password);

                if(data === undefined) {
                    decode_result(false);
                } else {
                    decode_result(true, data);
                }
            }
            reader.readAsArrayBuffer(f);
        }
    }

    function handleDragOver(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    }

    // Setup the dnd listeners.
    var dropZone = document.getElementById('drop_zone');
    dropZone.addEventListener('dragover', handleDragOver, false);
    dropZone.addEventListener('drop', handleFileSelect, false);

    function decode_result(status, data) {
        if(status == false) {
            document.getElementById('pem_out').innerText = 'Err';
        } else {
            var keycoder = new Keycoder();
            document.getElementById('pem_out').innerText = keycoder.to_pem(data);
        }
    }
    </script>
</body>
